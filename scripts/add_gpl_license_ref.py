#!/usr/bin/env python3
"""
Script to check source files for GNU GPL license and add a reference line to COPYING.txt.

Usage:
  python add_gpl_license_ref.py              # Dry run: report files needing license
  python add_gpl_license_ref.py --apply      # Apply changes to files
  python add_gpl_license_ref.py --apply -v  # Verbose output
"""

import argparse
import os
import re
import sys
from pathlib import Path

# File extensions to process
SOURCE_EXTENSIONS = {
    '.c', '.h', '.cpp', '.cc', '.cxx', '.hpp', '.py', '.sh', '.bat', '.ps1',
    '.md', '.txt', '.cmake',
}

# Directories to skip (third-party, generated, build output)
EXCLUDE_DIRS = {
    'Drivers', 'Middlewares', 'esp-idf', 'node_modules', '.git',
    'Debug', 'Release', 'out', 'build', '.vscode', '.cursor',
    'Third_Party', 'third_party', 'vendor', '__pycache__',
    'FatFs',  # Third-party FatFs library (has its own license)
    'IR-Data',  # Raw IR test data files
    'CMakeFiles',  # Generated by CMake
}

# Patterns that indicate a file already has license info
LICENSE_PATTERNS = [
    r'GNU\s+General\s+Public\s+License',
    r'GPL-\d',
    r'SPDX-License-Identifier',
    r'See\s+COPYING',
    r'See\s+LICENSE',
    r'Licensed\s+under',
    r'Apache\s+License',
    r'MIT\s+License',
    r'BSD\s+License',
    r'Unlicense',
    r'CC0-1\.0',
    r'Copyright\s+\(c\)\s+\d{4}.*\n.*License',  # Copyright with license
]

# License reference line by file type (comment style)
LICENSE_LINE = {
    '.c': '/* See COPYING.txt for license details. */',
    '.h': '/* See COPYING.txt for license details. */',
    '.cpp': '// See COPYING.txt for license details.',
    '.cc': '// See COPYING.txt for license details.',
    '.cxx': '// See COPYING.txt for license details.',
    '.hpp': '// See COPYING.txt for license details.',
    '.py': '# See COPYING.txt for license details.',
    '.sh': '# See COPYING.txt for license details.',
    '.bat': 'REM See COPYING.txt for license details.',
    '.ps1': '# See COPYING.txt for license details.',
    '.md': '<!-- See COPYING.txt for license details. -->',
    '.txt': 'See COPYING.txt for license details.',
    '.cmake': '# See COPYING.txt for license details.',
}


def should_skip_path(filepath: Path, root: Path) -> bool:
    """Return True if this path should be skipped."""
    rel = filepath.relative_to(root)
    parts = rel.parts
    for part in parts:
        if part in EXCLUDE_DIRS:
            return True
    return False


def has_license_content(content: str) -> bool:
    """Check if file content already contains license-related text."""
    # Read first 2KB (typical header region)
    header = content[:2048] if len(content) > 2048 else content
    header_lower = header.lower()

    for pattern in LICENSE_PATTERNS:
        if re.search(pattern, header, re.IGNORECASE | re.DOTALL):
            return True

    # Also check for "license" in first 50 lines
    lines = content.split('\n')[:50]
    for line in lines:
        if 'license' in line.lower() or 'copying' in line.lower():
            return True

    return False


def get_insert_position(content: str, ext: str) -> int:
    """
    Find where to insert the license line.
    Returns the index (character position) where the line should be inserted.
    Inserts at top (after shebang for scripts).
    """
    lines = content.split('\n')
    insert_line_idx = 0

    # Skip shebang for scripts
    if lines and lines[0].startswith('#!'):
        insert_line_idx = 1

    # Convert line index to character position
    char_pos = 0
    for idx, line in enumerate(lines):
        if idx >= insert_line_idx:
            break
        char_pos += len(line) + 1  # +1 for newline

    return char_pos


def add_license_line(content: str, ext: str, license_line: str) -> str:
    """Insert the license line at the appropriate position."""
    pos = get_insert_position(content, ext)

    prefix = content[:pos]
    suffix = content[pos:]

    # Add newline after license line
    line_with_newline = license_line + '\n'
    if suffix and not suffix.startswith('\n'):
        line_with_newline += '\n'

    return prefix + line_with_newline + suffix


# Files without extension that should be processed (e.g. CMakeLists.txt)
SPECIAL_FILES = {'cmakelists.txt'}


def process_file(filepath: Path, root: Path, apply: bool, verbose: bool) -> bool:
    """
    Process a single file. Returns True if file was modified or needs modification.
    """
    ext = filepath.suffix.lower()
    name_lower = filepath.name.lower()
    if ext not in SOURCE_EXTENSIONS and name_lower not in SPECIAL_FILES:
        return False

    if should_skip_path(filepath, root):
        return False

    try:
        content = filepath.read_text(encoding='utf-8', errors='replace')
    except Exception as e:
        if verbose:
            print(f"  Skip {filepath}: {e}", file=sys.stderr)
        return False

    if has_license_content(content):
        if verbose:
            print(f"  Skip {filepath}: already has license", file=sys.stderr)
        return False

    if name_lower == 'cmakelists.txt':
        license_line = '# See COPYING.txt for license details.'
    else:
        license_line = LICENSE_LINE.get(
            ext, '# See COPYING.txt for license details.'
        )
    rel_path = filepath.relative_to(root)

    if apply:
        new_content = add_license_line(content, ext, license_line)
        filepath.write_text(new_content, encoding='utf-8', newline='')
        print(f"  Added: {rel_path}")
        return True
    else:
        print(f"  Needs license: {rel_path}")
        return True


def main():
    parser = argparse.ArgumentParser(
        description='Check source files for GPL license and add reference to COPYING.txt'
    )
    parser.add_argument(
        '--apply',
        action='store_true',
        help='Apply changes to files (default is dry run)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Verbose output (show skipped files)'
    )
    parser.add_argument(
        'root',
        nargs='?',
        default=os.curdir,
        help='Project root directory (default: current directory)'
    )
    args = parser.parse_args()

    root = Path(args.root).resolve()
    if not root.is_dir():
        print(f"Error: {root} is not a directory", file=sys.stderr)
        sys.exit(1)

    print(f"Scanning: {root}")
    if not args.apply:
        print("Mode: DRY RUN (use --apply to make changes)\n")
    else:
        print("Mode: APPLY\n")

    count = 0
    for filepath in sorted(root.rglob('*')):
        if filepath.is_file():
            if process_file(filepath, root, args.apply, args.verbose):
                count += 1

    print(f"\nTotal: {count} file(s) {'modified' if args.apply else 'need license'}")
    return 0


if __name__ == '__main__':
    sys.exit(main())
